# Scheduled runs ONLY work from the repo's DEFAULT BRANCH (e.g. main).
# If you use another branch (e.g. development), merge this file to default and push.
name: Website Monitor (Phase 1)

on:
  schedule:
    - cron: "*/5 * * * *" # every 5 minutes
  workflow_dispatch:

concurrency:
  group: monitor
  cancel-in-progress: false # wait for current run; only one at a time (saves minutes)

jobs:
  monitor:
    runs-on: ubuntu-latest # free-tier runner only

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          # no cache: "npm" â€” package-lock.json is gitignored, so we use npm install only

      - name: Restore site state
        uses: actions/cache/restore@v4
        id: restore-state
        with:
          path: .monitor-state
          key: site-state-${{ runner.os }}

      - name: Restore state file for this run
        if: steps.restore-state.outputs.cache-hit == 'true'
        run: |
          cp .monitor-state/site_state.json site_state.json 2>/dev/null || true
          cp .monitor-state/down_since.json down_since.json 2>/dev/null || true

      - name: Restore node_modules cache
        uses: actions/cache/restore@v4
        id: node-cache
        with:
          path: node_modules
          key: node-modules-${{ runner.os }}-${{ hashFiles('package.json') }}

      - name: Install dependencies
        run: npm install

      - name: Save node_modules cache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: node_modules
          key: node-modules-${{ runner.os }}-${{ hashFiles('package.json') }}

      - name: Run monitor
        id: monitor
        run: |
          time node monitor.js 2> monitor_stderr.txt
          EXIT=$?
          echo "exit=$EXIT" >> $GITHUB_OUTPUT
          exit $EXIT
        continue-on-error: true

      - name: Save site state for next run
        if: always()
        run: |
          mkdir -p .monitor-state
          cp site_state.json .monitor-state/site_state.json 2>/dev/null || true
          cp down_since.json .monitor-state/down_since.json 2>/dev/null || true

      - name: Cache site state
        if: always()
        uses: actions/cache/save@v4
        with:
          path: .monitor-state
          key: site-state-${{ runner.os }}

      - name: Send Discord alert on failure (only when a site newly went DOWN)
        if: steps.monitor.outcome == 'failure'
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          if [ ! -f down_alert_report.json ]; then exit 0; fi
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          ALERT_TIME=$(TZ=Asia/Kolkata date '+%d/%m/%Y %I:%M:%S %p IST')
          BODY=$(jq -r '.newDownAlerts[] | "DOWN: " + .url + " (" + .reason + ")"' down_alert_report.json 2>/dev/null || cat monitor_stderr.txt 2>/dev/null | tail -20)
          CONTENT="ðŸš¨ **Website monitor**: one or more sites are DOWN.
          Alert time: $ALERT_TIME

          \`\`\`
          $BODY
          \`\`\`"
          curl -s -X POST \
            -H "Content-Type: application/json" \
            -d "$(jq -n --arg c "$CONTENT" '{content: $c}')" \
            "$DISCORD_WEBHOOK" || true

      - name: Send Discord alert when site goes SLOW (was UP)
        if: steps.monitor.outcome == 'success'
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          if [ ! -f slow_alert_report.json ]; then exit 0; fi
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          ALERT_TIME=$(TZ=Asia/Kolkata date '+%d/%m/%Y %I:%M:%S %p IST')
          BLOCK=$(jq -r '.slowAlerts[] | "â€¢ " + .url + "\n  - Response time: " + (.timeMs|tostring) + "ms\n  - Detected at: " + .detectedAt' slow_alert_report.json 2>/dev/null || true)
          CONTENT="âš ï¸ **Website monitor**: site(s) are SLOW (was UP).
          Alert time: $ALERT_TIME

          $RUN_URL

          \`\`\`
          $BLOCK
          \`\`\`"
          curl -s -X POST \
            -H "Content-Type: application/json" \
            -d "$(jq -n --arg c "$CONTENT" '{content: $c}')" \
            "$DISCORD_WEBHOOK" || true

      - name: Send Discord alert on recovery (site up again)
        if: steps.monitor.outcome == 'success'
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          if [ ! -f recovery_report.json ]; then exit 0; fi
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          BLOCK=$(jq -r '.recoveries[] | "â€¢ " + .url + (if .recoveredFrom == "slow" then "\n  - Back to normal at " + .resolvedAt else "\n  - Incident started at " + .incidentStartedAt + "\n  - Resolved at " + .resolvedAt + "\n  - Duration " + .durationText end)' recovery_report.json 2>/dev/null || true)
          CONTENT="âœ… **Website monitor**: site(s) are UP again (was down or slow).

          $RUN_URL

          \`\`\`
          $BLOCK
          \`\`\`"
          curl -s -X POST \
            -H "Content-Type: application/json" \
            -d "$(jq -n --arg c "$CONTENT" '{content: $c}')" \
            "$DISCORD_WEBHOOK" || true
